<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pics</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configure Tailwind CSS to use 'Inter' font
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for animations and specific elements not covered by Tailwind */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        #photobooth-container {
            max-width: 900px;
            width: 100%;
            background-color: #ffffff; /* Default background, will be changed by JS */
            border-radius: 1.5rem; /* rounded-3xl */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); /* shadow-xl */
            padding: 2.5rem; /* p-10 */
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: background-color 0.3s ease-in-out; /* Smooth transition for background color */
        }

        #camera-feed {
            width: 100%;
            max-width: 640px; /* Max width for the video feed */
            height: auto;
            border-radius: 0.75rem; /* rounded-xl */
            background-color: #333; /* Placeholder for no camera feed */
            aspect-ratio: 16 / 9; /* Common video aspect ratio */
            object-fit: cover;
            display: none; /* Hidden until camera starts */
            margin-bottom: 1.5rem; /* mb-6 */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        #countdown {
            font-size: 8rem; /* text-8xl */
            font-weight: 700; /* font-bold */
            color: #4b5563; /* Changed to a neutral gray */
            margin-bottom: 1.5rem; /* mb-6 */
            text-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            display: none; /* Hidden until countdown starts */
        }

        .button-primary {
            background-color: #4f46e5; /* bg-indigo-600 */
            color: #ffffff; /* text-white */
            font-weight: 700; /* font-bold */
            padding: 0.75rem 1.5rem; /* py-3 px-6 */
            border-radius: 0.5rem; /* rounded-lg */
            transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; /* transition */
            transition-duration: 300ms; /* duration-300 */
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); /* ease-in-out */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-md */
            outline: none; /* focus:outline-none */
            font-size: 1.25rem; /* text-xl */
        }
        .button-primary:hover {
            background-color: #4338ca; /* hover:bg-indigo-700 */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* hover:shadow-lg */
        }
        .button-primary:focus {
            --tw-ring-color: rgba(99, 102, 241, 0.75); /* focus:ring-indigo-500 */
            --tw-ring-opacity: 0.75; /* focus:ring-opacity-75 */
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
            outline: 2px solid transparent;
            outline-offset: 2px;
            box-shadow: 0 0 0 2px var(--tw-ring-color); /* focus:ring-2 */
        }


        .button-secondary {
            background-color: #e5e7eb; /* bg-gray-200 */
            color: #1f2937; /* text-gray-800 */
            font-weight: 700; /* font-bold */
            padding: 0.75rem 1.5rem; /* py-3 px-6 */
            border-radius: 0.5rem; /* rounded-lg */
            transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; /* transition */
            transition-duration: 300ms; /* duration-300 */
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); /* ease-in-out */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-md */
            outline: none; /* focus:outline-none */
            font-size: 1.125rem; /* text-lg */
        }
        .button-secondary:hover {
            background-color: #d1d5db; /* hover:bg-gray-300 */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* hover:shadow-lg */
        }
        .button-secondary:focus {
            --tw-ring-color: rgba(156, 163, 175, 0.75); /* focus:ring-gray-400 */
            --tw-ring-opacity: 0.75; /* focus:ring-opacity-75 */
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
            outline: 2px solid transparent;
            outline-offset: 2px;
            box-shadow: 0 0 0 2px var(--tw-ring-color); /* focus:ring-2 */
        }

        #results-area {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #photostrip-display {
            max-width: 100%;
            height: auto;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            margin-top: 1.5rem; /* mt-6 */
            margin-bottom: 1.5rem; /* mb-6 */
        }

        .thumbnail-wrapper {
            position: relative;
            width: 120px;
            height: auto;
            margin: 0.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            overflow: hidden; /* Ensure retake button stays within bounds */
        }

        .thumbnail-wrapper img {
            display: block;
            width: 100%;
            height: auto;
            object-fit: cover;
            border-radius: 0.5rem;
        }

        .retake-thumbnail-button {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: rgba(239, 68, 68, 0.8); /* Red-500 with opacity */
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            opacity: 0.9;
        }

        .retake-thumbnail-button:hover {
            background-color: rgba(220, 38, 38, 0.9); /* Darker red on hover */
            opacity: 1;
        }

        #thumbnails-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }

        /* Message Box Styling - This styling is still present but the JS calls to show it are removed. */
        #message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 30px;
            border-radius: 10px;
            z-index: 1000;
            display: none; /* Hidden by default */
            font-size: 1.5rem;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        /* Pulse animation for countdown */
        .animate-pulse-once {
            animation: pulse-once 1s ease-out forwards;
        }

        @keyframes pulse-once {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Color Swatch Styling */
        .color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 50%; /* Make them circular */
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .color-swatch.active {
            border-color: #4f46e5; /* Indigo for active state */
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .color-swatch:hover:not(.active) {
            transform: scale(1.05);
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
        }

        /* Radio button styling for outline options */
        .radio-option {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .radio-option input[type="radio"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            border: 2px solid #ccc;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 8px;
            outline: none;
            transition: border-color 0.2s ease-in-out;
            flex-shrink: 0;
        }

        .radio-option input[type="radio"]:checked {
            border-color: #4f46e5; /* Indigo */
            background-color: #4f46e5; /* Indigo */
        }

        .radio-option input[type="radio"]:checked::before {
            content: '';
            display: block;
            width: 10px;
            height: 10px;
            background-color: white;
            border-radius: 50%;
            margin: 3px;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-purple-100 to-indigo-200 min-h-screen flex items-center justify-center p-4">
    <div id="photobooth-container" class="bg-white rounded-3xl shadow-xl p-10 flex flex-col items-center">
        <h1 class="text-4xl font-extrabold text-gray-400 mb-6">ðŸ“¸ Photobooth!</h1>

        <!-- Camera Feed and Countdown Area -->
        <div class="relative w-full max-w-2xl mb-6">
            <video id="camera-feed" class="rounded-xl shadow-lg w-full h-auto" autoplay muted playsinline></video>
            <div id="countdown" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 text-gray-700 rounded-xl text-8xl font-bold" style="display: none;"></div>
            <!-- Initial message/prompt for camera activation -->
            <p id="camera-status-message" class="text-gray-600 mt-4 text-lg">Press "Activate Camera" to begin.</p>
        </div>

        <!-- Hidden Canvas for Image Processing -->
        <canvas id="photo-canvas" class="hidden"></canvas>

        <!-- Control Buttons -->
        <div id="controls" class="space-y-4 flex flex-col items-center justify-center w-full">
            <!-- Button to activate camera -->
            <button id="activate-camera-button" class="button-primary">Activate Camera</button>
            <!-- Button to start photo sequence, hidden until camera is active -->
            <button id="start-button" class="button-primary hidden">Start Photobooth!</button>
            
            <div class="flex space-x-4">
                <button id="retake-button" class="button-secondary hidden">Retake Photos</button>
                <a id="download-button" class="button-primary hidden" download="photobooth_strip.jpg">Download Strip</a>
            </div>

            <!-- Color Swatches for strip background -->
            <div id="color-options" class="flex items-center space-x-3 mt-4 hidden">
                <label class="text-gray-700 font-semibold text-lg">Strip Color:</label>
                <div id="color-swatches-container" class="flex space-x-2">
                    <div class="color-swatch" data-color="white" style="background-color: white;"></div>
                    <div class="color-swatch" data-color="black" style="background-color: black;"></div>
                    <div class="color-swatch" data-color="red" style="background-color: red;"></div>
                    <div class="color-swatch" data-color="blue" style="background-color: blue;"></div>
                    <div class="color-swatch" data-color="green" style="background-color: green;"></div>
                    <div class="color-swatch" data-color="yellow" style="background-color: yellow;"></div>
                    <div class="color-swatch" data-color="#FFD700" style="background-color: #FFD700;" title="Gold"></div>
                    <div class="color-swatch" data-color="#800080" style="background-color: #800080;" title="Purple"></div>
                    <div class="color-swatch" data-color="#FFA500" style="background-color: #FFA500;" title="Orange"></div>
                </div>
            </div>

            <!-- Outline Color Options -->
            <div id="outline-options" class="flex items-center space-x-3 mt-4 hidden">
                <label class="text-gray-700 font-semibold text-lg">Outline Color:</label>
                <div class="flex space-x-4">
                    <label class="radio-option">
                        <input type="radio" name="outlineColor" value="black" id="outline-black" checked>
                        <span>Black</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="outlineColor" value="white" id="outline-white">
                        <span>White</span>
                    </label>
                </div>
            </div>

            <!-- Timer Options -->
            <div id="timer-options" class="flex items-center space-x-3 mt-4 hidden">
                <label class="text-gray-700 font-semibold text-lg">Countdown:</label>
                <div class="flex space-x-4">
                    <label class="radio-option">
                        <input type="radio" name="countdownTime" value="1" id="timer-1s">
                        <span>1 Second</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="countdownTime" value="3" id="timer-3s" checked>
                        <span>3 Seconds</span>
                    </label>
                </div>
            </div>
        </div>

        <!-- Results Area -->
        <div id="results-area" class="w-full mt-8">
            <div id="thumbnails-container" class="flex flex-wrap justify-center gap-4"></div>
            <img id="photostrip-display" class="hidden" alt="Your Photostrip">
        </div>

        <!-- Custom Message Box (instead of alert) - This element is kept for structural integrity but will not be used for messages now -->
        <div id="message-box" class="hidden"></div>
    </div>

    <script>
        // Get references to DOM elements
        const photoboothContainer = document.getElementById('photobooth-container');
        const cameraFeed = document.getElementById('camera-feed');
        const photoCanvas = document.getElementById('photo-canvas');
        const activateCameraButton = document.getElementById('activate-camera-button');
        const startButton = document.getElementById('start-button');
        const retakeButton = document.getElementById('retake-button');
        const downloadButton = document.getElementById('download-button');
        const countdownDisplay = document.getElementById('countdown');
        const resultsArea = document.getElementById('results-area');
        const thumbnailsContainer = document.getElementById('thumbnails-container');
        const photostripDisplay = document.getElementById('photostrip-display');
        const messageBox = document.getElementById('message-box'); // Kept for reference but not used for pop-ups
        const cameraStatusMessage = document.getElementById('camera-status-message');
        const colorOptionsContainer = document.getElementById('color-options');
        const colorSwatchesContainer = document.getElementById('color-swatches-container');
        const outlineOptionsContainer = document.getElementById('outline-options');
        const outlineRadios = document.querySelectorAll('input[name="outlineColor"]');
        const timerOptionsContainer = document.getElementById('timer-options'); // New: Timer options container
        const timerRadios = document.querySelectorAll('input[name="countdownTime"]'); // New: Timer radio buttons

        // Canvas context for drawing
        const ctx = photoCanvas.getContext('2d');

        // Variables to manage the camera stream and captured photos
        let mediaStream;
        let capturedPhotos = [];
        let currentStripColor = 'white';
        let currentOutlineColor = 'black';
        let isRetakingIndividualPhoto = false;
        let retakeIndex = -1;
        let currentCountdownSeconds = 3; // New: Variable for configurable countdown

        // Configuration constants for the photobooth process
        const NUM_PHOTOS = 4;
        // Removed COUNTDOWN_SECONDS constant, now using currentCountdownSeconds
        const PHOTO_DISPLAY_DURATION_MS = 800;

        // Photostrip dimensions and text settings
        const STRIP_WIDTH = 600;
        const PHOTO_HEIGHT_ON_STRIP = 400;
        const STRIP_FONT_SIZE = 36;
        const STRIP_TEXT_COLOR = 'rgb(0, 0, 0)'; 
        const HEADER_HEIGHT_STRIP = 50;
        const FOOTER_HEIGHT = 100;
        const OUTLINE_THICKNESS = 10;
        const TEXT_PADDING_X = 20;
        // Adjusted TEXT_PADDING_Y to add more space above the text
        const TEXT_PADDING_Y = 40; 

        /**
         * Determines optimal text color based on background color for contrast.
         * This function will be used for the container's title and strip's text.
         * @param {string} bgColor - The background color (e.g., 'white', 'black', '#FFD700').
         * @returns {string} 'white' or 'black'.
         */
        function getContrastTextColor(bgColor) {
            const colorMap = {
                'white': [255, 255, 255],
                'black': [0, 0, 0],
                'red': [255, 0, 0],
                'blue': [0, 0, 255],
                'green': [0, 128, 0],
                'yellow': [255, 255, 0],
                '#FFD700': [255, 215, 0],
                '#800080': [128, 0, 128],
                '#FFA500': [255, 165, 0]
            };

            let r, g, b;
            if (colorMap[bgColor]) {
                [r, g, b] = colorMap[bgColor];
            } else if (bgColor.startsWith('#') && bgColor.length === 7) {
                r = parseInt(bgColor.substring(1, 3), 16);
                g = parseInt(bgColor.substring(3, 5), 16);
                b = parseInt(bgColor.substring(5, 7), 16);
            } else {
                const hex = bgColor.replace('#', '');
                r = parseInt(hex.substring(0, 2), 16);
                g = parseInt(hex.substring(2, 4), 16);
                b = parseInt(hex.substring(4, 6), 16);
                if (isNaN(r) || isNaN(g) || isNaN(b)) {
                    return 'white';
                }
            }

            const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;

            return luminance > 0.5 ? 'black' : 'white';
        }

        /**
         * Displays a custom message box instead of using alert().
         * This function is no longer called in the code.
         * @param {string} message - The message to display.
         * @param {number} duration - How long the message should be visible in milliseconds.
         */
        function showMessage(message, duration = 2000) {
            // This function is intentionally left empty as per user request to remove pop-ups.
            // You can uncomment the following lines if you ever want to re-enable it for debugging.
            // messageBox.textContent = message;
            // messageBox.style.display = 'block';
            // setTimeout(() => {
            //     messageBox.style.display = 'none';
            // }, duration);
        }

        /**
         * Stops the camera stream.
         */
        function stopCamera() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                cameraFeed.srcObject = null;
                cameraFeed.style.display = 'none'; // Hide the video element
                cameraStatusMessage.classList.remove('hidden'); // Show camera status message
            }
        }

        /**
         * Initializes the webcam and displays the live feed.
         * This function is now triggered by the "Activate Camera" button.
         */
        async function startCamera() {
            try {
                // Hide the activate camera button and status message
                activateCameraButton.classList.add('hidden');
                cameraStatusMessage.classList.add('hidden');

                // Request access to video (webcam)
                mediaStream = await navigator.mediaDevices.getUserMedia({ video: true });
                cameraFeed.srcObject = mediaStream; // Set the video element's source to the stream
                cameraFeed.style.display = 'block'; // Show the video feed

                // Show the main "Start Photobooth!" button and color/outline options once camera is ready
                startButton.classList.remove('hidden');
                colorOptionsContainer.classList.remove('hidden');
                outlineOptionsContainer.classList.remove('hidden');
                timerOptionsContainer.classList.remove('hidden'); // Show timer options
            } catch (err) {
                console.error("Error accessing camera:", err);
                // If camera access fails, show the activate camera button again
                activateCameraButton.classList.remove('hidden');
                cameraStatusMessage.classList.remove('hidden'); // Show status message again
                retakeButton.classList.add('hidden');
                downloadButton.classList.add('hidden');
                colorOptionsContainer.classList.add('hidden'); // Hide color options
                outlineOptionsContainer.classList.add('hidden'); // Hide outline options
                timerOptionsContainer.classList.add('hidden'); // Hide timer options
            }
        }

        /**
         * Performs a countdown, captures a photo, and displays it briefly.
         * @returns {Promise<string|null>} A promise that resolves with the Data URL of the captured photo, or null if capture fails.
         */
        async function capturePhotoWithCountdown(isIndividualRetake = false) {
            // Hide relevant controls during countdown and capture
            startButton.classList.add('hidden');
            retakeButton.classList.add('hidden');
            downloadButton.classList.add('hidden');
            colorOptionsContainer.classList.add('hidden');
            outlineOptionsContainer.classList.add('hidden');
            timerOptionsContainer.classList.add('hidden'); // Hide timer options during capture
            
            countdownDisplay.style.display = 'flex'; // Show countdown display
            for (let i = currentCountdownSeconds; i > 0; i--) { // Use currentCountdownSeconds
                countdownDisplay.textContent = i;
                countdownDisplay.classList.add('animate-pulse-once'); // Add animation class
                await new Promise(resolve => setTimeout(resolve, 900)); // Wait for animation + slight buffer
                countdownDisplay.classList.remove('animate-pulse-once'); // Remove class for next pulse
            }
            countdownDisplay.textContent = 'Smile!';
            await new Promise(resolve => setTimeout(resolve, 500)); // Give a moment for "Smile!"

            // Ensure video feed dimensions are available before drawing
            const videoWidth = cameraFeed.videoWidth;
            const videoHeight = cameraFeed.videoHeight;

            if (videoWidth === 0 || videoHeight === 0) {
                console.error("Video dimensions are zero, camera not ready for capture.");
                // Re-enable controls if capture fails (only if not an individual retake, as individual retake will restore them)
                if (!isRetakingIndividualPhoto) {
                    startButton.classList.remove('hidden');
                    retakeButton.classList.remove('hidden');
                    downloadButton.classList.remove('hidden');
                    colorOptionsContainer.classList.remove('hidden');
                    outlineOptionsContainer.classList.remove('hidden');
                    timerOptionsContainer.classList.remove('hidden'); // Show timer options if capture fails
                }
                return null;
            }

            // Set canvas dimensions to match the video feed
            photoCanvas.width = videoWidth;
            photoCanvas.height = videoHeight;

            // Draw the current video frame onto the canvas
            ctx.drawImage(cameraFeed, 0, 0, videoWidth, videoHeight);

            // Optional: Add a simple white border overlay
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 15;
            ctx.strokeRect(0, 0, videoWidth, videoHeight);

            // Get the image data as a JPEG Data URL
            const photoDataUrl = photoCanvas.toDataURL('image/jpeg', 0.9); // 0.9 quality for JPEG

            // Display the captured photo briefly
            cameraFeed.style.display = 'none'; // Hide live feed
            photostripDisplay.src = photoDataUrl;
            photostripDisplay.classList.remove('hidden'); // Show captured photo
            countdownDisplay.style.display = 'none'; // Hide countdown

            await new Promise(resolve => setTimeout(resolve, PHOTO_DISPLAY_DURATION_MS)); // Display for a short duration
            cameraFeed.style.display = 'block'; // Show live feed again (only if not stopping camera)

            return photoDataUrl;
        }

        /**
         * Creates a thumbnail element with a retake button.
         * @param {string} photoDataUrl - The Data URL of the photo.
         * @param {number} index - The index of the photo in the capturedPhotos array.
         * @returns {HTMLElement} The created thumbnail wrapper div.
         */
        function createThumbnailElement(photoDataUrl, index) {
            const wrapper = document.createElement('div');
            wrapper.classList.add('thumbnail-wrapper');

            const img = document.createElement('img');
            img.src = photoDataUrl;
            img.alt = `Photo ${index + 1}`;
            wrapper.appendChild(img);

            const retakeBtn = document.createElement('button');
            retakeBtn.classList.add('retake-thumbnail-button');
            retakeBtn.textContent = 'ðŸ”„'; // Refresh icon
            retakeBtn.title = `Retake Photo ${index + 1}`;
            retakeBtn.onclick = () => retakeIndividualPhoto(index);
            wrapper.appendChild(retakeBtn);

            return wrapper;
        }

        /**
         * Starts the full photobooth capture sequence.
         */
        async function startCaptureSequence() {
            // Hide all control buttons during the capture sequence
            activateCameraButton.classList.add('hidden');
            startButton.classList.add('hidden');
            retakeButton.classList.add('hidden');
            downloadButton.classList.add('hidden');
            cameraStatusMessage.classList.add('hidden'); // Hide status message during sequence
            colorOptionsContainer.classList.add('hidden'); // Hide color options during capture
            outlineOptionsContainer.classList.add('hidden'); // Hide outline options during capture
            timerOptionsContainer.classList.add('hidden'); // Hide timer options during capture

            thumbnailsContainer.innerHTML = '';
            photostripDisplay.classList.add('hidden');
            capturedPhotos = []; // Clear previous photos

            for (let i = 0; i < NUM_PHOTOS; i++) {
                const photoDataUrl = await capturePhotoWithCountdown(false); // Not an individual retake
                if (photoDataUrl) {
                    capturedPhotos.push(photoDataUrl);
                    // Add thumbnail to results area
                    const thumbnailElement = createThumbnailElement(photoDataUrl, i);
                    thumbnailsContainer.appendChild(thumbnailElement);
                } else {
                    // If capture fails, show retake option
                    retakeButton.classList.remove('hidden');
                    // Show color/outline/timer options if capture sequence was interrupted
                    colorOptionsContainer.classList.remove('hidden');
                    outlineOptionsContainer.classList.remove('hidden');
                    timerOptionsContainer.classList.remove('hidden');
                    // If sequence interrupted, stop camera
                    stopCamera();
                    return; // Stop sequence if a photo fails
                }
            }

            if (capturedPhotos.length === NUM_PHOTOS) {
                await createPhotoStrip(capturedPhotos);
                // After strip creation, show retake ALL and download
                retakeButton.classList.remove('hidden'); // Show retake button (for whole strip)
                downloadButton.classList.remove('hidden'); // Show download button
                
                // Turn off camera once the full sequence is complete and strip is generated
                stopCamera(); 

            } else {
                retakeButton.classList.remove('hidden'); // Allow retake even if partial
                // If sequence ended early, turn off camera
                stopCamera();
            }
        }

        /**
         * Handles retaking a single photo by its index.
         * @param {number} index - The index of the photo to retake.
         */
        async function retakeIndividualPhoto(index) {
            if (!mediaStream) {
                return;
            }

            isRetakingIndividualPhoto = true;
            retakeIndex = index;

            // Hide main controls during individual retake
            startButton.classList.add('hidden');
            retakeButton.classList.add('hidden');
            downloadButton.classList.add('hidden');
            colorOptionsContainer.classList.add('hidden');
            outlineOptionsContainer.classList.add('hidden');
            timerOptionsContainer.classList.add('hidden'); // Hide timer options during retake
            photostripDisplay.classList.add('hidden'); // Hide the generated strip temporarily

            // Pass true to indicate individual retake, so camera doesn't turn off immediately
            const newPhotoDataUrl = await capturePhotoWithCountdown(true);

            if (newPhotoDataUrl) {
                capturedPhotos[index] = newPhotoDataUrl; // Update the photo data in the array

                // Find the specific thumbnail and update its image source
                const thumbnailWrapper = thumbnailsContainer.children[index];
                if (thumbnailWrapper) {
                    const imgElement = thumbnailWrapper.querySelector('img');
                    if (imgElement) {
                        imgElement.src = newPhotoDataUrl;
                    }
                }
                await createPhotoStrip(capturedPhotos); // Regenerate strip with the updated photo

            } else {
                // Handle failure if needed
            }

            // Restore controls after individual retake (camera remains on)
            retakeButton.classList.remove('hidden'); // Show retake all button
            downloadButton.classList.remove('hidden'); // Show download button
            colorOptionsContainer.classList.remove('hidden'); // Show color options
            outlineOptionsContainer.classList.remove('hidden'); // Show outline options
            timerOptionsContainer.classList.remove('hidden'); // Show timer options
            isRetakingIndividualPhoto = false;
            retakeIndex = -1;
        }

        /**
         * Creates a single photostrip image from an array of Data URLs.
         * @param {string[]} photoDataUrls - Array of Data URLs for captured photos.
         * @returns {Promise<void>}
         */
        async function createPhotoStrip(photoDataUrls) {
            const finalStripCanvas = document.createElement('canvas');
            // Calculate total height including space for photos, header, and footer
            const totalPhotosHeight = photoDataUrls.length * PHOTO_HEIGHT_ON_STRIP;
            const totalCanvasHeight = totalPhotosHeight + HEADER_HEIGHT_STRIP + FOOTER_HEIGHT;

            finalStripCanvas.width = STRIP_WIDTH;
            finalStripCanvas.height = totalCanvasHeight;
            const finalStripCtx = finalStripCanvas.getContext('2d');

            // Fill background of the strip with the currently selected color
            finalStripCtx.fillStyle = currentStripColor;
            finalStripCtx.fillRect(0, 0, finalStripCanvas.width, finalStripCanvas.height);

            let yOffset = HEADER_HEIGHT_STRIP; // Start drawing photos after the header padding

            // Draw each photo onto the strip
            for (const dataUrl of photoDataUrls) {
                const img = new Image();
                img.src = dataUrl;
                await new Promise(resolve => img.onload = resolve); // Wait for image to load

                // Calculate aspect ratio
                const aspectRatio = img.width / img.height;

                // Determine drawing dimensions to fit within the allocated photo height for the strip
                let drawWidth = STRIP_WIDTH;
                let drawHeight = drawWidth / aspectRatio;

                if (drawHeight > PHOTO_HEIGHT_ON_STRIP) {
                    drawHeight = PHOTO_HEIGHT_ON_STRIP;
                    drawWidth = drawHeight * aspectRatio;
                }

                // Center the image within its allocated strip section
                const xCenterOffset = (STRIP_WIDTH - drawWidth) / 2;
                const yCenterOffset = (PHOTO_HEIGHT_ON_STRIP - drawHeight) / 2;

                finalStripCtx.drawImage(img, xCenterOffset, yOffset + yCenterOffset, drawWidth, drawHeight);
                yOffset += PHOTO_HEIGHT_ON_STRIP; 
            }

            // Add overall strip outline
            finalStripCtx.strokeStyle = currentOutlineColor;
            finalStripCtx.lineWidth = OUTLINE_THICKNESS;
            finalStripCtx.strokeRect(OUTLINE_THICKNESS / 2, OUTLINE_THICKNESS / 2, STRIP_WIDTH - OUTLINE_THICKNESS, totalCanvasHeight - OUTLINE_THICKNESS);

            // Add title and date at the bottom (within FOOTER_HEIGHT area)
            finalStripCtx.fillStyle = getContrastTextColor(currentStripColor); // Text color based on strip background
            
            // Draw title
            finalStripCtx.font = `${STRIP_FONT_SIZE}px 'Inter'`;
            finalStripCtx.textAlign = 'center'; // Center the text
            // Adjusted Y for spacing above the text
            finalStripCtx.fillText('Awesome Photobooth Fun!', STRIP_WIDTH / 2, yOffset + TEXT_PADDING_Y); 

            // Draw date only
            const date = new Date().toLocaleString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });
            finalStripCtx.font = `${STRIP_FONT_SIZE * 0.6}px 'Inter'`; // Smaller font for date
            finalStripCtx.fillText(date, STRIP_WIDTH / 2, yOffset + TEXT_PADDING_Y + STRIP_FONT_SIZE * 0.8); // Position date below title

            // Display the final photostrip
            const finalStripDataUrl = finalStripCanvas.toDataURL('image/jpeg', 0.95);
            photostripDisplay.src = finalStripDataUrl;
            photostripDisplay.classList.remove('hidden'); // Show the final strip
            downloadButton.href = finalStripDataUrl; // Set download link
            downloadButton.download = `photobooth_strip_${Date.now()}.jpg`; // Set filename for download
        }

        /**
         * Resets the photobooth to its initial state, ready for a new session.
         */
        function resetPhotobooth() {
            photostripDisplay.classList.add('hidden'); // Hide photostrip
            thumbnailsContainer.innerHTML = ''; // Clear thumbnails
            activateCameraButton.classList.remove('hidden'); // Show activate camera button
            startButton.classList.add('hidden'); // Hide the start photobooth button
            retakeButton.classList.add('hidden'); // Hide retake button
            downloadButton.classList.add('hidden'); // Hide download button
            cameraFeed.style.display = 'none'; // Hide live camera feed
            countdownDisplay.style.display = 'none'; // Hide countdown
            cameraStatusMessage.classList.remove('hidden'); // Show initial status message
            colorOptionsContainer.classList.add('hidden'); // Hide color options
            outlineOptionsContainer.classList.add('hidden'); // Hide outline options
            timerOptionsContainer.classList.add('hidden'); // Hide timer options
            capturedPhotos = []; // Clear stored photos
            
            // Reset color to default white for next session and update container background
            currentStripColor = 'white'; 
            photoboothContainer.style.backgroundColor = currentStripColor;
            
            // Visually reset active swatch
            const defaultSwatch = document.querySelector('.color-swatch[data-color="white"]');
            if (defaultSwatch) {
                // Remove active class from all swatches
                document.querySelectorAll('.color-swatch').forEach(swatch => swatch.classList.remove('active'));
                defaultSwatch.classList.add('active'); // Add active to default white
            }

            // Reset outline color to default black for next session and update radio button
            currentOutlineColor = 'black';
            const outlineBlackRadio = document.getElementById('outline-black');
            if (outlineBlackRadio) {
                outlineBlackRadio.checked = true;
            }

            // Reset timer to default 3s for next session
            currentCountdownSeconds = 3;
            const timer3sRadio = document.getElementById('timer-3s');
            if (timer3sRadio) {
                timer3sRadio.checked = true;
            }

            stopCamera(); // Ensure camera is off when resetting
        }

        /**
         * Initializes color swatches and sets the default active one.
         */
        function initializeColorSwatches() {
            // Set default active strip color
            currentStripColor = 'white';
            const defaultSwatch = document.querySelector('.color-swatch[data-color="white"]');
            if (defaultSwatch) {
                defaultSwatch.classList.add('active');
            }

            // Add event listener for color swatch clicks using event delegation
            colorSwatchesContainer.addEventListener('click', (event) => {
                const clickedSwatch = event.target.closest('.color-swatch');
                if (clickedSwatch) {
                    // Remove active class from all swatches
                    document.querySelectorAll('.color-swatch').forEach(swatch => swatch.classList.remove('active'));
                    // Add active class to the clicked swatch
                    clickedSwatch.classList.add('active');
                    // Update the currentStripColor variable
                    currentStripColor = clickedSwatch.dataset.color;
                    
                    // Update the background color of the main photobooth container
                    photoboothContainer.style.backgroundColor = currentStripColor;

                    // Update the title text color based on the container's new background for contrast
                    const titleElement = photoboothContainer.querySelector('h1');
                    if (titleElement) {
                        titleElement.style.color = getContrastTextColor(currentStripColor);
                    }

                    // If strip is already generated, regenerate with new color
                    if (capturedPhotos.length === NUM_PHOTOS && photostripDisplay.src) {
                        createPhotoStrip(capturedPhotos);
                    }
                }
            });
        }

        /**
         * Initializes outline color radio buttons and sets the default active one.
         */
        function initializeOutlineOptions() {
            // Set default active outline color
            currentOutlineColor = 'black';
            const outlineBlackRadio = document.getElementById('outline-black');
            if (outlineBlackRadio) {
                outlineBlackRadio.checked = true;
            }

            // Add event listeners for outline radio buttons
            outlineRadios.forEach(radio => {
                radio.addEventListener('change', (event) => {
                    currentOutlineColor = event.target.value;
                    // If strip is already generated, regenerate with new outline color
                    if (capturedPhotos.length === NUM_PHOTOS && photostripDisplay.src) {
                        createPhotoStrip(capturedPhotos);
                    }
                });
            });
        }

        /**
         * Initializes timer options and sets the default active one.
         */
        function initializeTimerOptions() {
            // Set default active timer option
            currentCountdownSeconds = 3;
            const timer3sRadio = document.getElementById('timer-3s');
            if (timer3sRadio) {
                timer3sRadio.checked = true;
            }

            // Add event listeners for timer radio buttons
            timerRadios.forEach(radio => {
                radio.addEventListener('change', (event) => {
                    currentCountdownSeconds = parseInt(event.target.value);
                });
            });
        }


        // --- Event Listeners ---
        activateCameraButton.addEventListener('click', startCamera);
        startButton.addEventListener('click', startCaptureSequence);
        retakeButton.addEventListener('click', resetPhotobooth);
        
        // Initialize options and welcome message on window load (after DOM is ready)
        window.onload = () => {
            initializeColorSwatches();
            initializeOutlineOptions(); // Initialize outline options
            initializeTimerOptions(); // New: Initialize timer options
            // Set initial container background color to match the default swatch
            photoboothContainer.style.backgroundColor = currentStripColor;
        };
    </script>
</body>
</html>
